##################################################
scallop

sc ll p

stable commutator length linear programmer

Copyright GPL 2008 by Danny Calegari
Copyright GPL 2008-2010 by Danny Calegari and Alden Walker

email dannyc@its.caltech.edu 
      awalker@caltech.edu
      
newest version available from the authors' websites:
  www.its.caltech.edu/~awalker
  www.its.caltech.edu/~dannyc
      
makes calls to glpk by the GNU project:
http://www.gnu.org/software/glpk/

and exlp by Masashi Kiyomi:
http://members.jcom.home.ne.jp/masashi777/exlp.html

and GMP by the GNU project:
http://gmplib.org/
##################################################

scallop computes stable commutator length for elements
of B_1(F), where F is a free group.

-----
Current version: 
-----
2.5 - March 8, 2011

-----
Theory:
-----
See Chapter 4 of:

Danny Calegari, scl, MSJ Memoirs 20. Mathematical Society of Japan, Tokyo, 2009


-----
Usage:
-----
	scallop [-r -e -v -h -mn -s filename] [i_1]w_1 [i_2]w_2 . . [i_n]w_n

where each i_j is an integer and w_j is a word in a free group, and where 
the formal sum of the w_i is in B_1(F).  The free group is defined implicitly 
to be the free group generated by all the letters appearing in any of the w_j.
For example, ./scallop abAB acAC computes scl(abAB+acAC) in the free 
group <a,b,c>.  Capital letters denote inverses.

Note that sum_j i_j*w_j is in B_1(F) iff each generator appears the same number
of times in the (weighted) sum as does its inverse.

The full list of options is:

-r causes scallop to use GMP and exlp internally for
exact rational output
-v verbose output
-e uses the rigorous (slower) version (see below)
-s filename draws an extremal surface, with each component being drawn 
   in a separate file.  Scallop also outputs a .fg (fatgraph) file, which 
   can be input to wallop (see Alden's website)
-h prints help
-mn uses polygons with up to n sides (this can potentially fix some of the rigor problems below)
-L[!] filename causes scallop to output the linear program into the files
      filename.A, .b, and .c, being the matrix, vector, and objectve function, 
      where we want to minimize cx subject to Ax==b and x>=0.
      A is a sparse matrix in matlab format -- b and c are just lists

------
Rigour:
------

The algorithm that scallop uses to compute scl is rigorous
for (finite linear combinations of) (cyclically) *alternating words*:
those where a generator never appears twice (or more) in a row. 
Hence: abAB is alternating, aaab is not, a is not.

For nonalternating input, scallop rigorously computes upper
bounds on scl. Moreover, the output is "statistically" correct
on *most* input, especially if the value of scl is small.

For a nonalternating chain, scallop will rigorously compute scl after 
applying the map x -> xxx for all generators x.  This is what the option -e
does internally.  This transformation obvously triples word length,
so it requires much more time and memory.


-----------
Compilation:
-----------

To compile, type

	make

in the directory containing the files.  This requires that
the glpk and gmp libraries are installed in the user's path.
This will typically be the case if glpk has been installed 
on the user's computer, possibly by using

	make prefix=PATH install

if the user's path is nonstandard.

Compiles successfully on:
OSX (intel) using glpk-4.28
Ubuntu 10.10, amd64 with glpk-4.43.


----------
Complexity:
----------
scallop comprises two rather distinct computationally intensive steps:
1) Building the linear program involves exhausting over all polygons 
   with number of sides less than 2*rank(F), where the possible sides are 
   basically all letters appearing in the chain.  Thus, a crude estimate
   for the number of polygons is (chain length)^(2*rank(F)).  These polygons
   must be stored in memory, so this complexity is for time and memory.
2) Doing the linear program.  The dimension of the space is the number of
   polygons, and the number of rows is approximately the square of the chain
   length.  This complexity is, of course, difficult to compute, but for
   reasonably sized problems (see below), is on the order of the creation step.
   
--------
Example output and timing:
--------
All tests run on Ubuntu 10.10 with a core i7 at 3.61 GHz.

****
time ./scallop abAB
scl ( abAB ) = 1/2 = 0.5

real	0m0.002s
user	0m0.000s
sys	0m0.000s

****
./scallop -v aabAAB
Words after cyclic reduction:
aabAAB
10 arcs (start letter, end letter, start word, end word) 
arc 0 : 0 3 0 0
arc 1 : 3 0 0 0
arc 2 : 0 4 0 0
arc 3 : 4 0 0 0
arc 4 : 1 3 0 0
arc 5 : 3 1 0 0
arc 6 : 1 4 0 0
arc 7 : 4 1 0 0
arc 8 : 2 5 0 0
arc 9 : 5 2 0 0
4 polygons (cyclic list of arcs) 
polygon 0 : 0 7 8 
polygon 1 : 1 6 9 
polygon 2 : 2 9 5 8 
polygon 3 : 3 4 
Started linear programming setup
Created constraints
optimal solution vector (weight by polygon type): 
polygon 0 : 1
polygon 1 : 1
polygon 2 : 0
polygon 3 : 0
scl ( aabAAB ) = 1/2 = 0.5


**** integer weights are faster than writing out the word n times:
time ./scallop abAAABBB 2ab 
scl ( abAAABBB + 2ab ) = 1 = 1

real	0m0.002s
user	0m0.000s
sys	0m0.000s

time ./scallop 1572abAAABBB 3144ab 
scl ( 1572abAAABBB + 3144ab ) = 1572 = 1572

real	0m0.002s
user	0m0.000s
sys	0m0.000s

time ./scallop abAAABBBabAAABBBabAAABBBabAAABBBabAAABBBabAAABBBabAAABBBabAAABBB 16ab 
scl ( abAAABBBabAAABBBabAAABBBabAAABBBabAAABBBabAAABBBabAAABBBabAAABBB + 16ab ) = 8 = 8

real	0m0.742s
user	0m0.740s
sys	0m0.000s


**** length 20
time ./scallop bAbbbaaabaBBAABaBBAA
scl ( bAbbbaaabaBBAABaBBAA ) = 14/13 = 1.07692

real	0m0.003s
user	0m0.000s
sys	0m0.000s

**** 
time ./scallop -e bAbbbaaabaBBAABaBBAA
scl ( bAbbbaaabaBBAABaBBAA ) = 14/13 = 1.07692

real	0m0.926s
user	0m0.900s
sys	0m0.020s


**** length 50
time ./scallop bababAbAbaabaBaBAABAbbABABaaaBBabbABAbAbAABaaBABBa
scl ( bababAbAbaabaBaBAABAbbABABaaaBBabbABAbAbAABaaBABBa ) = 725/387 = 1.87339

real	0m0.425s
user	0m0.420s
sys	0m0.000s

**** using exact arithmetic
time ./scallop -r bababAbAbaabaBaBAABAbbABABaaaBBabbABAbAbAABaaBABBa
scl ( bababAbAbaabaBaBAABAbbABABaaaBBabbABAbAbAABaaBABBa ) = 725/387 = 1.87339

real	0m8.180s
user	0m8.120s
sys	0m0.040s

**** it's too long for -e, but we can do -m5, which has a similar effect
time ./scallop -m5 bababAbAbaabaBaBAABAbbABABaaaBBabbABAbAbAABaaBABBa
Overriding max polygon sides to 5
scl ( bababAbAbaabaBaBAABAbbABABaaaBBabbABAbAbAABaaBABBa ) = 725/387 = 1.87339

real	0m10.142s
user	0m10.090s
sys	0m0.030s
(memory used: 500MB)

**** length 80; at this point linear programming takes significantly longer
     than creation and varies from word to word.  This is probably about
     the limit of reasonable computation
time ./scallop abbAbAAbabaaBABABBAbbbaabABaaBaaababababbaaaBAbAAbaBBAAAbABABBBBBabABBAABBAAAbaa
scl ( abbAbAAbabaaBABABBAbbbaabABaaBaaababababbaaaBAbAAbaBBAAAbABABBBBBabABBAABBAAAbaa ) = 818027/311196 = 2.62866

real	5m20.973s
user	5m20.410s
sys	0m0.020s    
(memory used: 700MB)

**** for higher rank, computation time increases more rapidly
time ./scallop abcdABCD
scl ( abcdABCD ) = 3/2 = 1.5

real	0m0.002s
user	0m0.000s
sys	0m0.000s

time ./scallop abcdABCDabcdABCD
scl ( abcdABCDabcdABCD ) = 3 = 3

real	0m0.002s
user	0m0.000s
sys	0m0.000s

time ./scallop abcdefghABCDEFGH
scl ( abcdefghABCDEFGH ) = 7/2 = 3.5

real	0m0.002s
user	0m0.000s
sys	0m0.000s

time ./scallop abcdefghABCDEFGHabcdefghABCDEFGH
scl ( abcdefghABCDEFGHabcdefghABCDEFGH ) = 7 = 7

real	0m1.852s
user	0m1.780s
sys	0m0.060s


-------
License:
-------

Scallop is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at your
option) any later version.

Scallop is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
License for more details.

You should have received a copy of the GNU General Public License
along with scallop.  If not, see http://www.gnu.org/licenses/.
